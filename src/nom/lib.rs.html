<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="Source to the Rust file `/home/travis/.cargo/registry/src/github.com-1ecc6299db9ec823/nom-3.2.1/src/lib.rs`.">
    <meta name="keywords" content="rust, rustlang, rust-lang">

    <title>lib.rs.html -- source</title>

    <link rel="stylesheet" type="text/css" href="../../normalize.css">
    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">
    

    
    
</head>
<body class="rustdoc source">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <div class="sidebar-menu">&#9776;</div>
        
        
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
</pre><pre class="rust ">
<span class="doccomment">//! nom, eating data byte by byte</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! nom is a parser combinator library with a focus on safe parsing,</span>
<span class="doccomment">//! streaming patterns, and as much as possible zero copy.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! The code is available on [Github](https://github.com/Geal/nom)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! There are a few [guides](http://rust.unhandledexpression.com/nom/home.html) with more details</span>
<span class="doccomment">//! about [the design of nom](http://rust.unhandledexpression.com/nom/how_nom_macros_work.html),</span>
<span class="doccomment">//! [how to write parsers](http://rust.unhandledexpression.com/nom/making_a_new_parser_from_scratch.html),</span>
<span class="doccomment">//! or the [error management system](http://rust.unhandledexpression.com/nom/error_management.html).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! If you are upgrading to nom 2.0, please read the</span>
<span class="doccomment">//! [migration document](http://rust.unhandledexpression.com/nom/upgrading_to_nom_2.html).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! See also the [FAQ](http://rust.unhandledexpression.com/nom/FAQ.html).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! # What are parser combinators?</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Parser combinators are a way to build parsers out of small functions. instead of</span>
<span class="doccomment">//! writing a huge grammar file then generaing code, like you would do with lex and yacc,</span>
<span class="doccomment">//! you write small functions, to parse small things like a character, or a number,</span>
<span class="doccomment">//! and then you assemble them in larger and larger functions, that can parse larger</span>
<span class="doccomment">//! parts of your formats.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! You end up with a list of small functions that you can reuse everywhere you need. Each</span>
<span class="doccomment">//! of them can be unit tested anf fuzzed separately.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! # nom parser design</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! All nom parsers follow the same convention. They are all functions with the following signature:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```ignore</span>
<span class="doccomment">//!  fn parser(input: I) -&gt; IResult&lt;I,O&gt; { ... }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Here is the definition of that `IResult` type:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! # #[macro_use] extern crate nom;</span>
<span class="doccomment">//! # use nom::{Err,Needed};</span>
<span class="doccomment">//! # fn main() {}</span>
<span class="doccomment">//! pub enum IResult&lt;I,O,E=u32&gt; {</span>
<span class="doccomment">//!   Done(I,O),</span>
<span class="doccomment">//!   Error(Err&lt;E&gt;), // indicates the parser encountered an error. E is a custom error type you can redefine</span>
<span class="doccomment">//!   /// Incomplete contains a Needed, an enum than can represent a known quantity of input data, or unknown</span>
<span class="doccomment">//!   Incomplete(Needed) // if the parser did not have enough data to decide</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! What it means:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * `Done(i,o)` means the parser was successful. `i` is the remaining part of the input, `o` is the correctly parsed value</span>
<span class="doccomment">//! The remaining part can then be used as input for other parsers called in a sequence</span>
<span class="doccomment">//! * `Error(e)` indicates the parser encountered an error. The `Err&lt;E&gt;` type is an enum of possible parser errors,</span>
<span class="doccomment">//! that can also contain a custom error that you&#39;d specify, by redefining the `E` error type</span>
<span class="doccomment">//! * `Incomplete(i)` means the parser did not have enough information to decide, and tells you, if possible,</span>
<span class="doccomment">//! how much data it needs</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! That way, you could write your own parser that recognizes the letter &#39;a&#39; like this:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! #[macro_use] extern crate nom;</span>
<span class="doccomment">//! use nom::{IResult,Needed,Err,ErrorKind};</span>
<span class="doccomment">//! # fn main() {}</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! fn a(input: &amp;[u8]) -&gt; IResult&lt;&amp;[u8], char&gt; {</span>
<span class="doccomment">//!  // if there is not enough data, we return Ìncomplete</span>
<span class="doccomment">//!  if input.len() == 0 {</span>
<span class="doccomment">//!    IResult::Incomplete(Needed::Size(1))</span>
<span class="doccomment">//!  } else {</span>
<span class="doccomment">//!    if input[0] == &#39;a&#39; as u8 {</span>
<span class="doccomment">//!      // the first part of the returned value is the remaining slice</span>
<span class="doccomment">//!      IResult::Done(&amp;input[1..], &#39;a&#39;)</span>
<span class="doccomment">//!    } else {</span>
<span class="doccomment">//!      IResult::Error(error_code!(ErrorKind::Custom(42)))</span>
<span class="doccomment">//!    }</span>
<span class="doccomment">//!  }</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Writing all the parsers manually, like this, is dangerous, despite Rust&#39;s safety features. There</span>
<span class="doccomment">//! are still a lot of mistakes one can make. That&#39;s why nom provides a list of macros to help in</span>
<span class="doccomment">//! developing parsers. As an example, here is a parser that would recognize the phrase</span>
<span class="doccomment">//! &quot;Hello &lt;someone&gt;&quot; and return the name of the person we hail:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! #[macro_use] extern crate nom;</span>
<span class="doccomment">//! use nom::alpha;</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! named!(hello, preceded!(tag!(&quot;Hello &quot;), alpha));</span>
<span class="doccomment">//! # use nom::IResult;</span>
<span class="doccomment">//! # fn main() {</span>
<span class="doccomment">//! #  assert_eq!(hello(b&quot;Hello nom.&quot;), IResult::Done(&amp;b&quot;.&quot;[..], &amp;b&quot;nom&quot;[..]));</span>
<span class="doccomment">//! # }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Let&#39;s deconstruct it:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * `named!` generates a function with the correct type. Without `named` here, we could write the parser</span>
<span class="doccomment">//! as follows:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! #[macro_use] extern crate nom;</span>
<span class="doccomment">//! use nom::{alpha,IResult};</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! fn hello(input: &amp;[u8]) -&gt; IResult&lt;&amp;[u8], &amp;[u8]&gt; {</span>
<span class="doccomment">//!   preceded!(input,</span>
<span class="doccomment">//!     tag!(&quot;Hello &quot;), alpha)</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! # fn main() {</span>
<span class="doccomment">//! #  assert_eq!(hello(b&quot;Hello nom.&quot;), IResult::Done(&amp;b&quot;.&quot;[..], &amp;b&quot;nom&quot;[..]));</span>
<span class="doccomment">//! # }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! By default, `named` makes a function that takes `&amp;[u8]` as input type, and returns `&amp;[u8]` as output type.</span>
<span class="doccomment">//! You can override it like this:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * `named!(hello&lt;&amp;str&gt;, ...):` would take `&amp;[u8]` as input type, and return `&amp;str` as output type.</span>
<span class="doccomment">//! * `named!(hello&lt;&amp;str, &amp;str&gt;, ...):` would take `&amp;str` as input type, and return `&amp;str` as output type.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! *Note* : when we don&#39;t use `named!`, we must pass the input as first argument of the top</span>
<span class="doccomment">//! level combinator (see the line `preceded!(input,` in the preceding code example). This is a macro trick</span>
<span class="doccomment">//! in nom to pass input from one combinator to the next by rewriting the call.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Next part of the parser: `preceded!(tag!(&quot;Hello &quot;), alpha))`. Here, `tag!` is a combinator that recognizes</span>
<span class="doccomment">//! a specific serie of bytes or characters. `alpha` is a function that recognizes alphabetical characters.</span>
<span class="doccomment">//! The `preceded!` combinator assembles them in a more complex parser: if both parsers are successful,</span>
<span class="doccomment">//! it returns the result of the second one (`alpha` is preceded by `tag!`).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! *Note* : combinators can assemble other combinators (macros), or parser functions, as long as they follow</span>
<span class="doccomment">//! the same interface. Here, `alpha` is a parser function already implemented in nom.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! # List of parsers and combinators</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Basic elements</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Those are used to recognize the lowest level elements of your grammar, like, &quot;here is a dot&quot;, or</span>
<span class="doccomment">//! &quot;here is an big endian integer&quot;.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * **char!**: matches one character: `char!(&#39;a&#39;)` will make a parser that recognizes the letter &#39;a&#39; (works with non ASCII chars too)</span>
<span class="doccomment">//! * **eof!**: `eof!()` returns its input if it is at the end of input data</span>
<span class="doccomment">//! * **is_a!, is_a_s!**: matches a sequence of any of the characters passed as arguments. `is_a!(&quot;ab1&quot;)` could recognize `ababa` or `1bb`. `is_a_s!` is a legacy combinator, it does exactly the same thing as `is_a`</span>
<span class="doccomment">//! * **is_not!, is_not_s!**: matches a sequence of none of the characters passed as arguments</span>
<span class="doccomment">//! * **one_of!**: matches one of the provided characters. `one_of!(&quot;abc&quot;)` could recognize &#39;a&#39;, &#39;b&#39;, or &#39;c&#39;. It also works with non ASCII characters</span>
<span class="doccomment">//! * **none_of!**: matches anything but the provided characters</span>
<span class="doccomment">//! * **tag!, tag_s!**: recognizes a specific suite of characters or bytes. `tag!(&quot;hello&quot;)` matches &quot;hello&quot;</span>
<span class="doccomment">//! * **tag_no_case!**: recognizes a suite of ASCII characters, case insensitive. `tag_no_case!(&quot;hello&quot;)` could match &quot;hello&quot;, &quot;Hello&quot; or even &quot;HeLlO&quot;</span>
<span class="doccomment">//! * **tag_no_case_s!** works like `tag_no_case` but on UTF-8 characters too (uses `&amp;str` as input). Note that case insensitive comparison is not well defined for unicode, and that you might have bad surprises. Also, this combinator allocates a new string for the comparison. Ponder for a bit before using this combinator</span>
<span class="doccomment">//! * **take!, take_s!**: takes a specific number of bytes or characters. `take!(5)` would return &quot;hello&quot; from the string &quot;hello world&quot;</span>
<span class="doccomment">//! * **take_str!**: same as `take!` but returning a `&amp;str`</span>
<span class="doccomment">//! * **take_till!, take_till_s!**: returns the longest list of bytes until the provided function succeeds. `take_till!(is_alphabetic)` with input &quot;123abc&quot; would return &quot;123&quot;</span>
<span class="doccomment">//! * **take_till1!, take_till1_s!**: same as `take_till!`, but the result must not be empty: `take_till1!(is_alphabetic)` would fail on &quot;abc&quot;</span>
<span class="doccomment">//! * **take_until!, take_until_s!**: returns the longest list of bytes until the provided tag is found. `take_until!(&quot;world&quot;)` with input &quot;Hello world!&quot; would return &quot;Hello &quot; and leave &quot;world!&quot; as remaining input</span>
<span class="doccomment">//! * **take_until1!**: same as `take_until!`, but cannot return an empty result</span>
<span class="doccomment">//! * **take_until_and_consume!, take_until_and_consume_s!**: same as `take_until!` but consumes the tag. `take_until_and_consume!(&quot;world&quot;)` with input &quot;Hello world!&quot; would return &quot;Hello &quot; and leave &quot;!&quot; as remaining input</span>
<span class="doccomment">//! * **take_until_and_consume1!**: same as `take_until_and_consume!`, but cannot return an empty result</span>
<span class="doccomment">//! * **take_until_either!**: returns the longest list of bytes until any of the provided characters are found</span>
<span class="doccomment">//! * **take_until_either_and_consume!**: same as `take_until_either!`, but consumes the terminating character</span>
<span class="doccomment">//! * **take_while!, take_while_s!**: returns the longest list of bytes for which the function is true. `take_while!(is_alphabetic)` with input &quot;abc123&quot; would return &quot;abc&quot;</span>
<span class="doccomment">//! * **take_while1!, take_while1_s!**: same as `take_while!`, but cannot return an empty result</span>
<span class="doccomment">//! * **value!**: you can use `value!` to always return the same result value without consuming input, like this: `value!(42)`. Or you can replace the result of a child parser with a predefined value, like this: `value!(42, tag!(&quot;abcd&quot;))` which would replace, if successful, the return value from &quot;abcd&quot;, to 42</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Parsing integers from binary formats can be done in two ways: with parser functions, or combinators with configurable endianness:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * configurable endianness: **i16!, i32!, i64!, u16!, u32!, u64!** are combinators that take as argument a `nom::Endianness`,</span>
<span class="doccomment">//! like this: `i16!(endianness)`. If the parameter is nom::Endianness::Big, parse a big endian i16 integer, otherwise a little endian i16 integer</span>
<span class="doccomment">//! * fixed endianness: the functions are prefixed by &quot;be_&quot; for big endian numbers, and by &quot;le_&quot; for little endian numbers, and the suffix is the type they parse to. As an example, &quot;be_u32&quot; parses a big endian unsigned integer stored in 32 bits.</span>
<span class="doccomment">//!   * **be_f32, be_f64, le_f32, le_f64**: recognize floating point numbers</span>
<span class="doccomment">//!   * **be_i8, be_i16, be_i32, be_i24, be_i32, be_i64**: big endian signed integers</span>
<span class="doccomment">//!   * **be_u8, be_u16, be_u32, be_u24, be_u32, be_u64**: big endian unsigned integers</span>
<span class="doccomment">//!   * **le_i8, le_i16, le_i32, le_i24, le_i32, le_i64**: little endian signed integers</span>
<span class="doccomment">//!   * **le_u8, le_u16, le_u32, le_u24, le_u32, le_u64**: little endian unsigned integers</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Modifiers</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * **complete!**: replaces a Incomplete returned by the child parser with an Error</span>
<span class="doccomment">//! * **cond!**: conditional combinator</span>
<span class="doccomment">//! * **cond_reduce!**: Conditional combinator with error</span>
<span class="doccomment">//! * **cond_with_error!**: Conditional combinator</span>
<span class="doccomment">//! * **expr_opt!**: evaluates an expression that returns a Option and returns a IResult::Done(I,T) if Some</span>
<span class="doccomment">//! * **expr_res!**: evaluates an expression that returns a Result and returns a IResult::Done(I,T) if Ok</span>
<span class="doccomment">//! * **flat_map!**:</span>
<span class="doccomment">//! * **map!**: maps a function on the result of a parser</span>
<span class="doccomment">//! * **map_opt!**: maps a function returning an Option on the output of a parser</span>
<span class="doccomment">//! * **map_res!**: maps a function returning a Result on the output of a parser</span>
<span class="doccomment">//! * **not!**: returns a result only if the embedded parser returns Error or Incomplete does not consume the input</span>
<span class="doccomment">//! * **opt!**: make the underlying parser optional</span>
<span class="doccomment">//! * **opt_res!**: make the underlying parser optional</span>
<span class="doccomment">//! * **parse_to!**: uses the parse method from std::str::FromStr to convert the current input to the specified type</span>
<span class="doccomment">//! * **peek!**: returns a result without consuming the input</span>
<span class="doccomment">//! * **recognize!**: if the child parser was successful, return the consumed input as produced value</span>
<span class="doccomment">//! * **return_error!**: prevents backtracking if the child parser fails</span>
<span class="doccomment">//! * **tap!**: allows access to the parser&#39;s result without affecting it</span>
<span class="doccomment">//! * **verify!**: returns the result of the child parser if it satisfies a verification function</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Error management and debugging</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * **add_return_error!**: Add an error if the child parser fails</span>
<span class="doccomment">//! * **dbg!**: Prints a message if the parser fails</span>
<span class="doccomment">//! * **dbg_dmp!**: Prints a message and the input if the parser fails</span>
<span class="doccomment">//! * **error_code!**: creates a parse error from a nom::ErrorKind</span>
<span class="doccomment">//! * **error_node!**: creates a parse error from a nom::ErrorKind and the next error in the parsing tree. if &quot;verbose-errors&quot; is not activated, it default to only the error code</span>
<span class="doccomment">//! * **error_node_position!**: creates a parse error from a nom::ErrorKind, the position in the input and the next error in the parsing tree. if &quot;verbose-errors&quot; is not activated, it default to only the error code</span>
<span class="doccomment">//! * **error_position!**: creates a parse error from a nom::ErrorKind and the position in the input if &quot;verbose-errors&quot; is not activated, it default to only the error code</span>
<span class="doccomment">//! * **fix_error!**: translate parser result from IResult to IResult with a custom type</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Choice combinators</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * **alt!**: try a list of parsers and return the result of the first successful one</span>
<span class="doccomment">//! * **alt_complete!**: is equivalent to the alt! combinator, except that it will not return Incomplete when one of the constituting parsers returns Incomplete. Instead, it will try the next alternative in the chain.</span>
<span class="doccomment">//! * **switch!**: choose the next parser depending on the result of the first one, if successful, and returns the result of the second parser</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! # Sequence combinators</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * **delimited!**: delimited(opening, X, closing) returns X</span>
<span class="doccomment">//! * **do_parse!**: do_parse applies sub parsers in a sequence. it can store intermediary results and make them available for later parsers</span>
<span class="doccomment">//! * **pair!**: pair(X,Y), returns (x,y)</span>
<span class="doccomment">//! * **permutation!**: applies its sub parsers in a sequence, but independent from their order this parser will only succeed if all of its sub parsers succeed</span>
<span class="doccomment">//! * **preceded!**: preceded(opening, X) returns X</span>
<span class="doccomment">//! * **separated_pair!**: separated_pair(X,sep,Y) returns (x,y)</span>
<span class="doccomment">//! * **terminated!**: terminated(X, closing) returns X</span>
<span class="doccomment">//! * **tuple!**: chains parsers and assemble the sub results in a tuple.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Applying a parser multiple times</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * **count!**: Applies the child parser a specified number of times</span>
<span class="doccomment">//! * **count_fixed!**: Applies the child parser a fixed number of times and returns a fixed size array The type must be specified and it must be Copy</span>
<span class="doccomment">//! * **fold_many0!**: Applies the parser 0 or more times and folds the list of return values</span>
<span class="doccomment">//! * **fold_many1!**: Applies the parser 1 or more times and folds the list of return values</span>
<span class="doccomment">//! * **fold_many_m_n!**: Applies the parser between m and n times (n included) and folds the list of return value</span>
<span class="doccomment">//! * **length_count!**: gets a number from the first parser, then applies the second parser that many times</span>
<span class="doccomment">//! * **many0!**: Applies the parser 0 or more times and returns the list of results in a Vec</span>
<span class="doccomment">//! * **many1!**: Applies the parser 1 or more times and returns the list of results in a Vec</span>
<span class="doccomment">//! * **many_m_n!**: Applies the parser between m and n times (n included) and returns the list of results in a Vec</span>
<span class="doccomment">//! * **many_till!**: Applies the first parser until the second applies. Returns a tuple containing the list of results from the first in a Vec and the result of the second.</span>
<span class="doccomment">//! * **separated_list!**: separated_list(sep, X) returns Vec will return Incomplete if there may be more elements</span>
<span class="doccomment">//! * **separated_list_complete!**: This is equivalent to the separated_list! combinator, except that it will return Error when either the separator or element subparser returns Incomplete.</span>
<span class="doccomment">//! * **separated_nonempty_list!**: separated_nonempty_list(sep, X) returns Vec will return Incomplete if there may be more elements</span>
<span class="doccomment">//! * **separated_nonempty_list_complete!**: This is equivalent to the separated_nonempty_list! combinator, except that it will return Error when either the separator or element subparser returns Incomplete.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Text parsing</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * **escaped!**: matches a byte string with escaped characters.</span>
<span class="doccomment">//! * **escaped_transform!**: matches a byte string with escaped characters, and returns a new string with the escaped characters replaced</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Binary format parsing</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * **length_data!**: gets a number from the first parser, than takes a subslice of the input of that size, and returns that subslice</span>
<span class="doccomment">//! * **length_bytes!**: alias for `length_data`</span>
<span class="doccomment">//! * **length_value!**: gets a number from the first parser, takes a subslice of the input of that size, then applies the second parser on that subslice. If the second parser returns Incomplete, length_value will return an error</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Bit stream parsing</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * **bits!**: transforms the current input type (byte slice `&amp;[u8]`) to a bit stream on which bit specific parsers and more general combinators can be applied</span>
<span class="doccomment">//! * **bytes!**: transforms its bits stream input back into a byte slice for the underlying parsers.</span>
<span class="doccomment">//! * **tag_bits!**: matches an integer pattern to a bitstream. The number of bits of the input to compare must be specified</span>
<span class="doccomment">//! * **take_bits!**: generates a parser consuming the specified number of bits</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Whitespace delimited formats parsing</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * **eat_separator!**: helper macros to build a separator parser</span>
<span class="doccomment">//! * **sep!**: sep is the parser rewriting macro for whitespace separated formats</span>
<span class="doccomment">//! * **wrap_sep!**:</span>
<span class="doccomment">//! * **ws!**:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Remaining combinators</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * **apply!**: emulate function currying: apply!(my_function, arg1, arg2, ...) becomes my_function(input, arg1, arg2, ...)</span>
<span class="doccomment">//! * **apply_m!**: emulate function currying for method calls on structs apply_m!(self.my_function, arg1, arg2, ...) becomes self.my_function(input, arg1, arg2, ...)</span>
<span class="doccomment">//! * **call!**: Used to wrap common expressions and function as macros</span>
<span class="doccomment">//! * **call_m!**: Used to called methods then move self back into self</span>
<span class="doccomment">//! * **closure!**: Wraps a parser in a closure</span>
<span class="doccomment">//! * **method!**: Makes a method from a parser combination</span>
<span class="doccomment">//! * **named!**: Makes a function from a parser combination</span>
<span class="doccomment">//! * **named_args!**: Makes a function from a parser combination with arguments.</span>
<span class="doccomment">//! * **named_attr!**: Makes a function from a parser combination, with attributes</span>
<span class="doccomment">//! * **try_parse!**: A bit like std::try!, this macro will return the remaining input and parsed value if the child parser returned Done, and will do an early return for Error and Incomplete this can provide more flexibility than do_parse! if needed</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Character test functions</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! use those functions with a combinator like `take_while!`:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * **is_alphabetic**: Tests if byte is ASCII alphabetic: A-Z, a-z</span>
<span class="doccomment">//! * **is_alphanumeric**: Tests if byte is ASCII alphanumeric: A-Z, a-z, 0-9</span>
<span class="doccomment">//! * **is_digit**: Tests if byte is ASCII digit: 0-9</span>
<span class="doccomment">//! * **is_hex_digit**: Tests if byte is ASCII hex digit: 0-9, A-F, a-f</span>
<span class="doccomment">//! * **is_oct_digit**: Tests if byte is ASCII octal digit: 0-7</span>
<span class="doccomment">//! * **is_space**: Tests if byte is ASCII space or tab</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Remaining functions (sort those out in the other categories)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * **alpha**: Recognizes one or more lowercase and uppercase alphabetic characters: a-zA-Z</span>
<span class="doccomment">//! * **alphanumeric**: Recognizes one or more numerical and alphabetic characters: 0-9a-zA-Z</span>
<span class="doccomment">//! * **anychar**: </span>
<span class="doccomment">//! * **begin**: </span>
<span class="doccomment">//! * **crlf**: </span>
<span class="doccomment">//! * **digit**: Recognizes one or more numerical characters: 0-9</span>
<span class="doccomment">//! * **double**: Recognizes floating point number in a byte string and returns a f64</span>
<span class="doccomment">//! * **double_s**: Recognizes floating point number in a string and returns a f64</span>
<span class="doccomment">//! * **eol**: </span>
<span class="doccomment">//! * **float**: Recognizes floating point number in a byte string and returns a f32</span>
<span class="doccomment">//! * **float_s**: Recognizes floating point number in a string and returns a f32</span>
<span class="doccomment">//! * **hex_digit**: Recognizes one or more hexadecimal numerical characters: 0-9, A-F, a-f</span>
<span class="doccomment">//! * **hex_u32**: Recognizes a hex-encoded integer</span>
<span class="doccomment">//! * **line_ending**: Recognizes an end of line (both &#39;\n&#39; and &quot;\r\n&quot;)</span>
<span class="doccomment">//! * **multispace**: Recognizes one or more spaces, tabs, carriage returns and line feeds</span>
<span class="doccomment">//! * **newline**: Matches a newline character &#39;\n&#39;</span>
<span class="doccomment">//! * **non_empty**: Recognizes non empty buffers</span>
<span class="doccomment">//! * **not_line_ending**: </span>
<span class="doccomment">//! * **oct_digit**: Recognizes one or more octal characters: 0-7</span>
<span class="doccomment">//! * **rest**: Return the remaining input.</span>
<span class="doccomment">//! * **rest_s**: Return the remaining input, for strings.</span>
<span class="doccomment">//! * **shift**: </span>
<span class="doccomment">//! * **sized_buffer**: </span>
<span class="doccomment">//! * **space**: Recognizes one or more spaces and tabs</span>
<span class="doccomment">//! * **tab**: Matches a tab character &#39;\t&#39;</span>
<span class="doccomment">//! * **tag_cl**: </span>
<span class="doccomment">//!</span>
<span class="doccomment">//! # Example</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! #[macro_use]</span>
<span class="doccomment">//! extern crate nom;</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! use nom::{IResult,digit};</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! // Parser definition</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! use std::str;</span>
<span class="doccomment">//! use std::str::FromStr;</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! // We parse any expr surrounded by parens, ignoring all whitespaces around those</span>
<span class="doccomment">//! named!(parens&lt;i64&gt;, ws!(delimited!( tag!(&quot;(&quot;), expr, tag!(&quot;)&quot;) )) );</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! // We transform an integer string into a i64, ignoring surrounding whitespaces</span>
<span class="doccomment">//! // We look for a digit suite, and try to convert it.</span>
<span class="doccomment">//! // If either str::from_utf8 or FromStr::from_str fail,</span>
<span class="doccomment">//! // we fallback to the parens parser defined above</span>
<span class="doccomment">//! named!(factor&lt;i64&gt;, alt!(</span>
<span class="doccomment">//!     map_res!(</span>
<span class="doccomment">//!       map_res!(</span>
<span class="doccomment">//!         ws!(digit),</span>
<span class="doccomment">//!         str::from_utf8</span>
<span class="doccomment">//!       ),</span>
<span class="doccomment">//!       FromStr::from_str</span>
<span class="doccomment">//!     )</span>
<span class="doccomment">//!   | parens</span>
<span class="doccomment">//!   )</span>
<span class="doccomment">//! );</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! // We read an initial factor and for each time we find</span>
<span class="doccomment">//! // a * or / operator followed by another factor, we do</span>
<span class="doccomment">//! // the math by folding everything</span>
<span class="doccomment">//! named!(term &lt;i64&gt;, do_parse!(</span>
<span class="doccomment">//!     init: factor &gt;&gt;</span>
<span class="doccomment">//!     res:  fold_many0!(</span>
<span class="doccomment">//!         pair!(alt!(tag!(&quot;*&quot;) | tag!(&quot;/&quot;)), factor),</span>
<span class="doccomment">//!         init,</span>
<span class="doccomment">//!         |acc, (op, val): (&amp;[u8], i64)| {</span>
<span class="doccomment">//!             if (op[0] as char) == &#39;*&#39; { acc * val } else { acc / val }</span>
<span class="doccomment">//!         }</span>
<span class="doccomment">//!     ) &gt;&gt;</span>
<span class="doccomment">//!     (res)</span>
<span class="doccomment">//!   )</span>
<span class="doccomment">//! );</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! named!(expr &lt;i64&gt;, do_parse!(</span>
<span class="doccomment">//!     init: term &gt;&gt;</span>
<span class="doccomment">//!     res:  fold_many0!(</span>
<span class="doccomment">//!         pair!(alt!(tag!(&quot;+&quot;) | tag!(&quot;-&quot;)), term),</span>
<span class="doccomment">//!         init,</span>
<span class="doccomment">//!         |acc, (op, val): (&amp;[u8], i64)| {</span>
<span class="doccomment">//!             if (op[0] as char) == &#39;+&#39; { acc + val } else { acc - val }</span>
<span class="doccomment">//!         }</span>
<span class="doccomment">//!     ) &gt;&gt;</span>
<span class="doccomment">//!     (res)</span>
<span class="doccomment">//!   )</span>
<span class="doccomment">//! );</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! fn main() {</span>
<span class="doccomment">//!   assert_eq!(expr(b&quot;1+2&quot;),         IResult::Done(&amp;b&quot;&quot;[..], 3));</span>
<span class="doccomment">//!   assert_eq!(expr(b&quot;12+6-4+3&quot;),    IResult::Done(&amp;b&quot;&quot;[..], 17));</span>
<span class="doccomment">//!   assert_eq!(expr(b&quot;1+2*3+4&quot;),     IResult::Done(&amp;b&quot;&quot;[..], 11));</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!   assert_eq!(expr(b&quot;(2)&quot;),         IResult::Done(&amp;b&quot;&quot;[..], 2));</span>
<span class="doccomment">//!   assert_eq!(expr(b&quot;2*(3+4)&quot;),     IResult::Done(&amp;b&quot;&quot;[..], 14));</span>
<span class="doccomment">//!   assert_eq!(expr(b&quot;2*2/(5-1)+3&quot;), IResult::Done(&amp;b&quot;&quot;[..], 4));</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="attribute">#![<span class="ident">cfg_attr</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>), <span class="ident">feature</span>(<span class="ident">no_std</span>))]</span>
<span class="attribute">#![<span class="ident">cfg_attr</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>), <span class="ident">feature</span>(<span class="ident">collections</span>))]</span>
<span class="attribute">#![<span class="ident">cfg_attr</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>), <span class="ident">no_std</span>)]</span>
<span class="attribute">#![<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;nightly&quot;</span>, <span class="ident">feature</span>(<span class="ident">test</span>))]</span>
<span class="attribute">#![<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;nightly&quot;</span>, <span class="ident">feature</span>(<span class="ident">const_fn</span>))]</span>
<span class="attribute">#![<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;nightly&quot;</span>, <span class="ident">feature</span>(<span class="ident">plugin</span>))]</span>
<span class="attribute">#![<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;nightly&quot;</span>, <span class="ident">plugin</span>(<span class="ident">compiler_error</span>))]</span>
<span class="comment">//#![warn(missing_docs)]</span>

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>))]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">collections</span>;
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;regexp&quot;</span>)]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">regex</span>;
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;regexp_macros&quot;</span>)]</span>
<span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">lazy_static</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">memchr</span>;
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;nightly&quot;</span>)]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">test</span>;

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;nightly&quot;</span>))]</span>
<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">unused_macros</span>)]</span>
<span class="attribute">#[<span class="ident">macro_export</span>]</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">compiler_error</span> {
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>:<span class="ident">expr</span>) <span class="op">=&gt;</span> {
      <span class="ident">INVALID_NOM_SYNTAX_PLEASE_SEE_FAQ</span> <span class="comment">//https://github.com/Geal/nom/blob/master/doc/FAQ.md#using-nightly-to-get-better-error-messages</span>
    }
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>))]</span>
<span class="kw">mod</span> <span class="ident">std</span> {
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
  <span class="kw">pub</span> <span class="kw">use</span> <span class="ident">core</span>::{<span class="ident">fmt</span>, <span class="ident">cmp</span>, <span class="ident">iter</span>, <span class="ident">option</span>, <span class="ident">result</span>, <span class="ident">ops</span>, <span class="ident">slice</span>, <span class="ident">str</span>, <span class="ident">mem</span>, <span class="ident">convert</span>};
  <span class="kw">pub</span> <span class="kw">use</span> <span class="ident">collections</span>::{<span class="ident">boxed</span>, <span class="ident">vec</span>, <span class="ident">string</span>};
  <span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">prelude</span> {
    <span class="kw">pub</span> <span class="kw">use</span> <span class="ident">core</span>::<span class="ident">prelude</span> <span class="kw">as</span> <span class="ident">v1</span>;
  }
}

<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">util</span>::<span class="kw-2">*</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">traits</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;verbose-errors&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">verbose_errors</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;verbose-errors&quot;</span>))]</span>
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">simple_errors</span>::<span class="kw-2">*</span>;

<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">internal</span>::<span class="kw-2">*</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">macros</span>::<span class="kw-2">*</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">branch</span>::<span class="kw-2">*</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">sequence</span>::<span class="kw-2">*</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">multi</span>::<span class="kw-2">*</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">methods</span>::<span class="kw-2">*</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">bytes</span>::<span class="kw-2">*</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">bits</span>::<span class="kw-2">*</span>;

<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">nom</span>::<span class="kw-2">*</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">character</span>::<span class="kw-2">*</span>;

<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">whitespace</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;regexp&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">regexp</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>)]</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;stream&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">stream</span>::<span class="kw-2">*</span>;

<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">str</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">mod</span> <span class="ident">util</span>;
<span class="kw">mod</span> <span class="ident">traits</span>;

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;verbose-errors&quot;</span>)]</span> <span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">verbose_errors</span>;

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;verbose-errors&quot;</span>))]</span> <span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">simple_errors</span>;

<span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">mod</span> <span class="ident">internal</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">mod</span> <span class="ident">macros</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">mod</span> <span class="ident">branch</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">mod</span> <span class="ident">sequence</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">mod</span> <span class="ident">multi</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">methods</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">mod</span> <span class="ident">bytes</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">bits</span>;

<span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">mod</span> <span class="ident">nom</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">mod</span> <span class="ident">character</span>;

<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">whitespace</span>;

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;regexp&quot;</span>)]</span>
<span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">mod</span> <span class="ident">regexp</span>;

<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>)]</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;stream&quot;</span>)]</span>
<span class="kw">mod</span> <span class="ident">stream</span>;

<span class="kw">mod</span> <span class="ident">str</span>;
</pre>
</section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>↑</dt>
                    <dd>Move up in search results</dd>
                    <dt>↓</dt>
                    <dd>Move down in search results</dd>
                    <dt>↹</dt>
                    <dd>Switch tab</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt style="width:31px;">+ / -</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "nom";
    </script>
    <script src="../../main.js"></script>
    <script defer src="../../search-index.js"></script>
</body>
</html>