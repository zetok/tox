initSidebarItems({"enum":[["GenError","Base type for generator errors"]],"fn":[["set_be_u16","Write an unsigned 2 bytes integer (big-endian order). Equivalent to `gen_be_u16!(v)`"],["set_be_u32","Write an unsigned 4 bytes integer (big-endian order). Equivalent to `gen_be_u32!(v)`"],["set_be_u64","Write an unsigned 8 bytes integer (big-endian order). Equivalent to `gen_be_u64!(v)`"],["set_be_u8","Write an unsigned 1 byte integer. Equivalent to `gen_be_u8!(v)`"],["set_le_u16","Write an unsigned 2 bytes integer (little-endian order). Equivalent to `gen_le_u16!(v)`"],["set_le_u32","Write an unsigned 4 bytes integer (little-endian order). Equivalent to `gen_le_u32!(v)`"],["set_le_u64","Write an unsigned 8 bytes integer (little-endian order). Equivalent to `gen_le_u64!(v)`"],["set_le_u8","Write an unsigned 1 byte integer. Equivalent to `gen_le_u8!(v)`"]],"macro":[["do_gen","Applies sub-generators in a sequence."],["gen_align","`gen_align!(I, u8) => I -> Result<I,E>` Align the output buffer to the next multiple of specified value."],["gen_at_offset","`gen_at_offset!(usize, I -> Result<I,E>) => I -> Result<I,E>` Combinator to call generator at an absolute offset."],["gen_at_rel_offset","`gen_at_offset!(usize, I -> Result<I,E>) => I -> Result<I,E>` Combinator to call generator at a relative offset."],["gen_be_f32","`gen_be_f32!(I, f32) => I -> Result<I,E>` Write a 4 byte float."],["gen_be_f64","`gen_be_f64!(I, f64) => I -> Result<I,E>` Write a 8 byte float."],["gen_be_i16","`gen_be_i16!(I, i16) => I -> Result<I,E>` Write a signed 2 byte integer."],["gen_be_i24","`gen_be_i24!(I, i24) => I -> Result<I,E>` Write a signed 3 byte integer."],["gen_be_i32","`gen_be_i32!(I, i32) => I -> Result<I,E>` Write a signed 4 byte integer."],["gen_be_i64","`gen_be_i64!(I, i64) => I -> Result<I,E>` Write a signed 8 byte integer."],["gen_be_i8","`gen_be_i8!(I, i8) => I -> Result<I,E>` Write a signed 1 byte integer."],["gen_be_u16","`gen_be_u16!(I, u8) => I -> Result<I,E>` Write an unsigned 2 bytes integer (using big-endian order)."],["gen_be_u24","`gen_be_u24!(I, u8) => I -> Result<I,E>` Write an unsigned 3 bytes integer (using big-endian order)."],["gen_be_u32","`gen_be_u32!(I, u8) => I -> Result<I,E>` Write an unsigned 4 bytes integer (using big-endian order)."],["gen_be_u64","`gen_be_u64!(I, u8) => I -> Result<I,E>` Write an unsigned 8 bytes integer (using big-endian order). `rust,ignore let r = gen_be_u64!((&mut mem,0),0x0102030405060708u64);`"],["gen_be_u8","`gen_be_u8!(I, u8) => I -> Result<I,E>` Write an unsigned 1 byte integer."],["gen_call","Used to wrap common expressions and function as macros"],["gen_cond","`gen_cond!(bool, I -> Result<I,E>) => I -> Result<I,E>` Conditional combinator"],["gen_copy","`gen_copy!(I, &[u8], u8) => I -> Result<I,E>` Writes a slice, copying only the specified number of bytes to the output buffer."],["gen_if_else","`gen_if_else!(bool, I -> Result<I,E>, I -> Result<I,E>) => I -> Result<I,E>` Conditional combinator, with alternate generator."],["gen_le_f32","`gen_le_f32!(I, f32) => I -> Result<I,E>` Write a 4 byte float."],["gen_le_f64","`gen_le_f64!(I, f64) => I -> Result<I,E>` Write a 8 byte float."],["gen_le_i16","`gen_le_i16!(I, i16) => I -> Result<I,E>` Write a signed 2 byte integer."],["gen_le_i24","`gen_le_i24!(I, i24) => I -> Result<I,E>` Write a signed 3 byte integer."],["gen_le_i32","`gen_le_i32!(I, i32) => I -> Result<I,E>` Write a signed 4 byte integer."],["gen_le_i64","`gen_le_i64!(I, i64) => I -> Result<I,E>` Write a signed 8 byte integer."],["gen_le_i8","`gen_le_i8!(I, i8) => I -> Result<I,E>` Write a signed 1 byte integer."],["gen_le_u16","`gen_le_u16!(I, u8) => I -> Result<I,E>` Write an unsigned 2 bytes integer (using little-endian order)."],["gen_le_u24","`gen_le_u24!(I, u8) => I -> Result<I,E>` Write an unsigned 3 bytes integer (using little-endian order)."],["gen_le_u32","`gen_le_u32!(I, u8) => I -> Result<I,E>` Write an unsigned 4 bytes integer (using little-endian order)."],["gen_le_u64","`gen_le_u64!(I, u8) => I -> Result<I,E>` Write an unsigned 8 bytes integer (using little-endian order). `rust,ignore let r = gen_le_u64!((&mut mem,0),0x0102030405060708u64);`"],["gen_le_u8","`gen_le_u8!(I, u8) => I -> Result<I,E>` Write an unsigned 1 byte integer."],["gen_length_slice",""],["gen_many","`gen_many!(I, Iterable<V>, Fn(I,V)) => I -> Result<I,E>` Applies the generator `$f` to every element of `$l`, passing arguments by value."],["gen_many_byref","`gen_many_byref!(I, Iterable<V>, Fn(I,V)) => I -> Result<I,E>` Applies the generator `$f` to every element of `$l`, where arguments of $l are references"],["gen_many_ref","`gen_many_ref!(I, Iterable<V>, Fn(I,V)) => I -> Result<I,E>` Applies the generator `$f` to every element of `$l`, passing arguments by reference."],["gen_skip","`gen_skip!(I, u8) => I -> Result<I,E>` Skip the specified number of bytes."],["gen_slice","`gen_slice!(I, &[u8]) => I -> Result<I,E>` Writes a slice, copying it entirely to the output buffer."]]});